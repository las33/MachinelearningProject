F1 ordenado de forma crescente
n_list de 1-itemset

para cada i de F1:
	build_pattern_tree(i, {j | j pertence a F1 e j > i}, nulo)

build_pattern_tree(atual_no, prox_nos, pai_no):
	para cada i de prox_nos:
		adiciona pai_no em atual_no e i caso nao seja nulo para interseção
		x.n_list = NL_intersecao(atual_no, i)
		se x.suporte == atual_no.suporte:
			atual_no.equivalentes += i
		senao se x.suporte >= limiar:
			cria no 'filho'
			filho = i
			filho.suporte = x.suporte
			atual_no.filhos += filho

	se pai_no nao for nulo:
		atual_no = pai_no + atual_no

	escreve atual_no em F com seu suporte

	se atual_no tem equivalentes:		
		s = todos os subconjuntos de atual_no.equivalentes
		para cada s adiciona atual_no e escreve em F com suporte igual ao de atual_no

	se atual_no tem filhos:
		para cada filho em atual_no.filhos:
			filho.equivalentes = atual_no.equivalentes
			build_pattern_tree(filho, {j | j pertence a atual.filhos e j > filho}, atual_no)